/* test_ds_cpp.cc - Generated by AI
 * 
 * This is a unit test for the shu_ds.h library. Includes all edge cases.
 * Testing is done by Google Test.
*/

#define SHU_DS_IMPLEMENTATION
#include "shu_ds.h"
#include <gtest/gtest.h>

TEST(ShuDsTest, ArrHeader)
{
    int *arr = NULL;
    EXPECT_EQ(shuds_arr_header(arr), nullptr);

    arr = (int *)malloc(sizeof(shuds_arr_header_t) + 10 * sizeof(int));
    arr = (int *)((char *)arr + sizeof(shuds_arr_header_t));
    shuds_arr_header_t *header = shuds_arr_header(arr);
    header->len = 5;
    header->capacity = 10;

    EXPECT_EQ(shuds_arr_getlen(arr), 5);
    EXPECT_EQ(shuds_arr_get_capacity(arr), 10);

    free(header);
}

TEST(ShuDsTest, ArrResize)
{
    int *arr = NULL;
    shuds_arr_resize(arr, 10);
    EXPECT_NE(arr, nullptr);
    EXPECT_EQ(shuds_arr_get_capacity(arr), 10);

    shuds_arr_resize(arr, 20);
    EXPECT_EQ(shuds_arr_get_capacity(arr), 20);

    shuds_arr_resize(arr, 0);
    EXPECT_EQ(arr, nullptr);
}

TEST(ShuDsTest, ArrShrinkToFit)
{
    int *arr = NULL;
    shuds_arr_resize(arr, 10);
    shuds_arr_header(arr)->len = 5;

    shuds_arr_shrink_to_fit(arr);
    EXPECT_EQ(shuds_arr_get_capacity(arr), 5);
    EXPECT_EQ(shuds_arr_getlen(arr), 5);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrAppend)
{
    int *arr = NULL;
    shuds_arr_append(arr, 42);
    EXPECT_EQ(shuds_arr_getlen(arr), 1);
    EXPECT_EQ(arr[0], 42);

    shuds_arr_append(arr, 100);
    EXPECT_EQ(shuds_arr_getlen(arr), 2);
    EXPECT_EQ(arr[1], 100);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrAppendn)
{
    int *arr = NULL;
    int values[] = {1, 2, 3, 4, 5};

    shuds_arr_appendn(arr, values, 5);
    EXPECT_EQ(shuds_arr_getlen(arr), 5);
    for (int i = 0; i < 5; i++)
    {
        EXPECT_EQ(arr[i], values[i]);
    }

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrInsert)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 3);

    shuds_arr_insert(arr, 1, 2);
    EXPECT_EQ(shuds_arr_getlen(arr), 3);
    EXPECT_EQ(arr[1], 2);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrInsertn)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 4);

    int values[] = {2, 3};
    shuds_arr_insertn(arr, 1, values, 2);
    EXPECT_EQ(shuds_arr_getlen(arr), 4);
    EXPECT_EQ(arr[1], 2);
    EXPECT_EQ(arr[2], 3);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrPopBack)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 2);

    EXPECT_EQ(shuds_arr_pop_back(arr), 2);
    EXPECT_EQ(shuds_arr_getlen(arr), 1);

    EXPECT_EQ(shuds_arr_pop_back(arr), 1);
    EXPECT_EQ(shuds_arr_getlen(arr), 0);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrDel)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 2);
    shuds_arr_append(arr, 3);

    shuds_arr_del(arr, 1);
    EXPECT_EQ(shuds_arr_getlen(arr), 2);
    EXPECT_EQ(arr[0], 1);
    EXPECT_EQ(arr[1], 3);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrDeln)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 2);
    shuds_arr_append(arr, 3);
    shuds_arr_append(arr, 4);

    shuds_arr_deln(arr, 1, 2);
    EXPECT_EQ(shuds_arr_getlen(arr), 2);
    EXPECT_EQ(arr[0], 1);
    EXPECT_EQ(arr[1], 4);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrFirstLast)
{
    int *arr = NULL;
    shuds_arr_append(arr, 1);
    shuds_arr_append(arr, 2);
    shuds_arr_append(arr, 3);

    EXPECT_EQ(shuds_arr_first(arr), 1);
    EXPECT_EQ(shuds_arr_last(arr), 3);

    shuds_arr_free(arr);
}

TEST(ShuDsTest, ArrFree)
{
    int *arr = NULL;
    shuds_arr_resize(arr, 10);
    EXPECT_NE(arr, nullptr);

    shuds_arr_free(arr);
    EXPECT_EQ(arr, nullptr);
}

TEST(ShuDsTest, EdgeCases)
{
    // Test 1: Large array
    {
        int *arr = NULL;
        const size_t large_size = 1000000; // 1 million elements

        // Append a large number of elements
        for (size_t i = 0; i < large_size; i++)
        {
            shuds_arr_append(arr, (int)i);
        }

        // Verify length and capacity
        EXPECT_EQ(shuds_arr_getlen(arr), large_size);
        EXPECT_GE(shuds_arr_get_capacity(arr), large_size);

        // Verify elements
        for (size_t i = 0; i < large_size; i++)
        {
            EXPECT_EQ(arr[i], (int)i);
        }

        shuds_arr_free(arr);
    }

    // Test 2: Empty array operations
    {
        int *arr = NULL;

        // Operations on an empty array
        EXPECT_EQ(shuds_arr_getlen(arr), 0);
        EXPECT_EQ(shuds_arr_get_capacity(arr), 0);
        EXPECT_EQ(shuds_arr_pop_back(arr), 0); // Pop on empty array
        EXPECT_EQ(shuds_arr_first(arr), 0);    // First on empty array
        EXPECT_EQ(shuds_arr_last(arr), 0);     // Last on empty array

        // Insert into an empty array
        shuds_arr_append(arr, 0);

        // Delete from an array with one element
        shuds_arr_del(arr, 0);
        EXPECT_EQ(shuds_arr_getlen(arr), 0);

        shuds_arr_free(arr);
    }

    // Test 3: Out-of-bounds access
    {
        int *arr = NULL;
        shuds_arr_append(arr, 1);
        shuds_arr_append(arr, 2);

        // Access out-of-bounds indices
        EXPECT_EQ(shuds_arr_first(arr), 1);
        EXPECT_EQ(shuds_arr_last(arr), 2);
        EXPECT_EQ(arr[2], 0); // Access beyond length (should not crash)

        // Delete out-of-bounds index
        shuds_arr_del(arr, 5); // Should do nothing
        EXPECT_EQ(shuds_arr_getlen(arr), 2);

        shuds_arr_free(arr);
    }

    // Test 4: Repeated resizing
    {
        int *arr = NULL;
        const size_t resize_count = 1000;

        // Repeatedly resize the array
        for (size_t i = 0; i < resize_count; i++)
        {
            shuds_arr_resize(arr, i + 1);
            EXPECT_EQ(shuds_arr_get_capacity(arr), i + 1);
        }

        // Verify length and capacity
        EXPECT_EQ(shuds_arr_getlen(arr), 0); // Length should remain 0
        EXPECT_EQ(shuds_arr_get_capacity(arr), resize_count);

        shuds_arr_free(arr);
    }

    // Test 5: Mixed operations
    {
        int *arr = NULL;

        // Append elements
        shuds_arr_append(arr, 1);
        shuds_arr_append(arr, 2);
        shuds_arr_append(arr, 3);

        // Insert elements
        shuds_arr_insert(arr, 1, 42);
        EXPECT_EQ(shuds_arr_getlen(arr), 4);
        EXPECT_EQ(arr[1], 42);

        // Delete elements
        shuds_arr_del(arr, 2);
        EXPECT_EQ(shuds_arr_getlen(arr), 3);
        EXPECT_EQ(arr[2], 3);

        // Pop elements
        EXPECT_EQ(shuds_arr_pop_back(arr), 3);
        EXPECT_EQ(shuds_arr_getlen(arr), 2);

        // Append more elements
        shuds_arr_append(arr, 100);
        EXPECT_EQ(shuds_arr_getlen(arr), 3);
        EXPECT_EQ(arr[2], 100);

        // Shrink to fit
        shuds_arr_shrink_to_fit(arr);
        EXPECT_EQ(shuds_arr_get_capacity(arr), 3);

        shuds_arr_free(arr);
    }

    // Test 6: Null pointer handling
    {
        int *arr = NULL;

        // Operations on a null array
        EXPECT_EQ(shuds_arr_getlen(arr), 0);
        EXPECT_EQ(shuds_arr_get_capacity(arr), 0);
        EXPECT_EQ(shuds_arr_pop_back(arr), 0);
        EXPECT_EQ(shuds_arr_first(arr), 0);
        EXPECT_EQ(shuds_arr_last(arr), 0);

        // Resize a null array
        shuds_arr_resize(arr, 10);
        EXPECT_NE(arr, nullptr);
        EXPECT_EQ(shuds_arr_get_capacity(arr), 10);

        // Free a null array
        shuds_arr_free(arr);
        EXPECT_EQ(arr, nullptr);
    }
}

int main(int argc, char **argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}

